# Architecture knowledge

## ​Парадигмы программирования

[**Парадигма программирования**](https://ru.wikipedia.org/wiki/%D0%9F%D0%B0%D1%80%D0%B0%D0%B4%D0%B8%D0%B3%D0%BC%D0%B0_%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F) — это совокупность идей и понятий, определяющих стиль написания компьютерных программ \(подход к программированию\). Это способ концептуализации, определяющий организацию вычислений и структурирование работы, выполняемой компьютером.

[**Реактивное программирование**](https://ru.wikipedia.org/wiki/Реактивное_программирование) — парадигма программирования, ориентированная на асинхронные потоки данных и распространение изменений. Это означает, что должна существовать возможность легко выражать статические и динамические потоки данных, а также то, что нижележащая модель исполнения должна автоматически распространять изменения благодаря потоку данных. [https://habr.com/post/279715/](https://habr.com/post/279715/)

[**Процедурное программирование**](https://ru.wikipedia.org/wiki/%D0%9F%D1%80%D0%BE%D1%86%D0%B5%D0%B4%D1%83%D1%80%D0%BD%D0%BE%D0%B5_%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5) — программирование на императивном языке, при котором последовательно выполняемые операторы можно собрать в подпрограммы, то есть более крупные целостные единицы кода, с помощью механизмов самого языка.

* Basic \(до появления Visual Basic\)
* Си
* C++
* КОБОЛ
* Фортран
* Pascal

[**Функциональное программирование**](https://ru.wikipedia.org/wiki/%D0%A4%D1%83%D0%BD%D0%BA%D1%86%D0%B8%D0%BE%D0%BD%D0%B0%D0%BB%D1%8C%D0%BD%D0%BE%D0%B5_%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5) — парадигма программирования, в которой процесс вычисления трактуется как вычисление значений функций в математическом понимании последних \(в отличие от функций как подпрограмм в процедурном программировании\).  
Противопоставляется парадигме императивного программирования, которая описывает процесс вычислений как последовательное изменение состояний \(в значении, подобном таковому в теории автоматов\). При необходимости, в функциональном программировании вся совокупность последовательных состояний вычислительного процесса представляется явным образом, например, как список.

[**Объектно-ориентированное программирование**](https://ru.wikipedia.org/wiki/%D0%9E%D0%B1%D1%8A%D0%B5%D0%BA%D1%82%D0%BD%D0%BE-%D0%BE%D1%80%D0%B8%D0%B5%D0%BD%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%BD%D0%BE%D0%B5_%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5) — методология программирования, основанная на представлении программы в виде совокупности объектов, каждый из которых является экземпляром определенного класса, а классы образуют иерархию наследования.

* **Наследование** — свойство системы, позволяющее описать новый класс на основе уже существующего с частично или полностью заимствующейся функциональностью. Класс, от которого производится наследование, называется базовым, родительским или суперклассом. Новый класс — потомком, наследником, дочерним или производным классом.
* **Инкапсуляция** — свойство системы, которое позволяет объединять данные и код, манипулирующий этими данными, а также защищает и то, и другое от внешнего вмешательства или неправильного использования, скрывает реализацию.
* **Полиморфизм** — свойство системы, позволяющее использовать объекты с одинаковым интерфейсом без информации о типе и внутренней структуре объекта.
* **Абстрагирование** — означает выделение значимой информации и исключение из рассмотрения незначимой. В ООП рассматривают лишь абстракцию данных \(нередко называя её просто «абстракцией»\), подразумевая набор значимых характеристик объекта, доступный остальной программе.

## [SOLID](https://ru.wikipedia.org/wiki/SOLID_%28%D0%BE%D0%B1%D1%8A%D0%B5%D0%BA%D1%82%D0%BD%D0%BE-%D0%BE%D1%80%D0%B8%D0%B5%D0%BD%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%BD%D0%BE%D0%B5_%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5%29)

* **`Принцип единственности ответственности`**`(The Single Responsibility Principle)` - на каждый объект должна быть возложена одна единственная обязанность
* **`Принцип открытости/закрытости`**`(The Open Closed Principle)`- сущности должны быть открыты для расширения, но закрыты для модификации
* **`Принцип замещения Лисков`**`(The Liskov Substitution Principle)` - Объекты в программе могут быть заменены их наследниками без изменения свойств программы
* **`Принцип разделения интерфейса`**`(The Interface Segregation Principle)` - Много специализированных интерфейсов лучше, чем один универсальный
* **`Принцип инверсии зависимости`**`(The Dependency Inversion Principle)` - Зависимости внутри системы строятся на основе абстракций. Модули верхнего уровня не зависят от модулей нижнего уровня. Абстракции не должны зависеть от деталей. Детали должны зависеть от абстракций

Шпаргалка по SOLID-принципам - [https://habr.com/post/208442/](https://habr.com/post/208442/)

## [Design pattern](https://ru.wikipedia.org/wiki/%D0%A8%D0%B0%D0%B1%D0%BB%D0%BE%D0%BD_%D0%BF%D1%80%D0%BE%D0%B5%D0%BA%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F)

Шаблон проектирования или паттерн \(design pattern\) в разработке программного обеспечения —  это часто встречающееся решение определённой проблемы при проектировании архитектуры программ.

Обычно шаблон не является законченным образцом, который может быть прямо преобразован в код; это лишь пример решения задачи, который можно использовать в различных ситуациях. Объектно-ориентированные шаблоны показывают отношения и взаимодействия между классами или объектами, без определения того, какие конечные классы или объекты приложения будут использоваться.

* Fundamental - Общие
  * `Делегирование` -  объект внешне выражает некоторое поведение, но в реальности передаёт ответственность за выполнение этого поведения связанному объекту.
  * `Неизменяемый интерфейс` -  создание объекта, состояние которого не может быть изменено после создания.
  * `Интерфейс`  - общий метод для структурирования компьютерных программ для того, чтобы их было проще понять.
  * `Контейнер свойств` - позволяет добавлять дополнительные свойства для класса в контейнер \(внутри класса\), вместо расширения класса новыми свойствами.
* Creational - Порождающие \(предоставляют механизмы инициализации, позволяя создавать объекты удобным способом\)
  * `Абстрактная фабрика` -   Необходимо создавать объекты классов не имеющих иерархической связи, но логически связанных между собой. Абстрактный класс-фабрика определяет общий интерфейс таких фабрик. Его подклассы обладают конкретной реализацией методов по созданию разных объектов.
  * `Фабрика` -  Для того, чтобы система оставалась независимой от различных типов объектов, паттерн Factory Method использует механизм полиморфизма - классы всех конечных типов наследуют от одного абстрактного базового класса, предназначенного для полиморфного использования. В этом базовом классе определяется единый интерфейс, через который пользователь будет оперировать объектами конечных типов.
  * `Multiton`
  * `Singleton` -   Необходимо создание объекта класса таким образом, чтобы гарантировать невозможность инициализации другого объекта того же класса. Обычно сам класс контролирует наличие единственного экземпляра и он же предоставляет при необходимости к нему доступ.
  * `Prototype` - используется, если создание объекта класса требует много времени или является достаточно сложным. Тогда вместо создания нескольких объектов класса используется копирование существующего объекта.
  * `Lazy initialization` -  объект, инициализируемый только во время первого обращения к нему.
* Structural - Структурные \(определяют отношения между классами и объектами, позволяя им работать совместно\)
  * `Adapter` - применяется при необходимости использовать вместе несвязанные классы. Поведение адаптируемого класса при этом изменяется на необходимое.
  * `Decorator` - Класс, расширяющий функциональность другого класса без использования наследования.
  * `Facade` - Объект, который абстрагирует работу с несколькими классами, объединяя их в единое целое.
  * `Единая точка входа` - Обеспечивает унифицированный интерфейс для интерфейсов в подсистеме. Front Controller определяет высокоуровневый интерфейс, упрощающий использование подсистемы.
  * `Proxy` - Объект, который является посредником между двумя другими объектами, и который реализует/ограничивает доступ к объекту, к которому обращаются через него.
* Behavioral - Поведенчиское \( используются для того, чтобы упростить взаимодействие между сущностями\)
  * `Интерпретатор`
  * `Iterator` -  позволяет последовательно обойти все элементы составного объекта, не зная деталей внутреннего представления данных.
  * `Observer` - Определяет зависимость типа «один ко многим» между объектами таким образом, что при изменении состояния одного объекта все зависящие от него оповещаются об этом и автоматически обновляются.
  * `Visitor` -  позволяет создавать новые операции, не меняя классы объектов, над которыми эти операции могут выполняться.
  * `Состояние` -  это поведенческий паттерн проектирования, который позволяет объектам менять поведение в зависимости от своего состояния.
* Архитектурные
  * [Model-View-Controller](https://ru.wikipedia.org/wiki/Model-View-Controller) \(MVC\) Модель-представление-контроллер.
  * [Model-View-Presenter](https://ru.wikipedia.org/wiki/Model-View-Presenter) \(MVP\)
  * [Model-View-View Model](https://ru.wikipedia.org/wiki/Model-View-View_Model) \(MVVM\)

##  Различия MVP & MVVM & MVP

 Модель обладает следующими признаками:

* Модель — это бизнес-логика приложения;
* Модель обладает знаниями о себе самой и не знает о контроллерах и представлениях;
* Для некоторых проектов модель — это просто слой данных \(DAO, база данных, XML-файл\);
* Для других проектов модель — это менеджер базы данных, набор объектов или просто логика приложения;

 Представление обладает следующими признаками:

* В представлении реализуется отображение данных, которые получаются от модели любым способом;
* В некоторых случаях, представление может иметь код, который реализует некоторую бизнес-логику.

### Model-View-Controller

 У архитектуры MVC есть два варианта: **контроллер-супервизор \(supervising controller\)** и **пассивное представление \(passive view\)**.

#### S**upervising controller**

![](../.gitbook/assets/image%20%288%29.png)

Диаграмма иллюстрирует идеологию паттерна. Здecь, представление определяет как слушателей, так и обратные вызовы; представление передает вход в контроллер.

Контроллер принимает входные данные, а представление — выходные, однако большое число операций происходит и между ними. Данная архитектура хорошо подходит только для небольших проектов.

#### P**assive view**

![](../.gitbook/assets/image%20%287%29.png)

Главная идея пассивного представления MVC — это то, что представление полностью управляется контроллером. Помимо этого, код четко разделен на два уровня: бизнес логику и логику отображения:

* Бизнес логика — то, как работает приложение
* Логика отображения — то, как выглядит приложение

###  Model-View-Presenter

 Данная архитектура облегчает unit-тестирование, **презентер \(presenter\)** прост для написание тестов, а также может многократно использоваться, потому что представление может реализовать несколько интерфейсов.

![](../.gitbook/assets/image%20%284%29.png)

 Данный подход позволяет создавать абстракцию представления. Для этого необходимо выделить интерфейс представления с определенным набором свойств и методов. Презентер, в свою очередь, получает ссылку на реализацию интерфейса, подписывается на события представления и по запросу изменяет модель

###  Model-View-View Model

 Существует другой способ биндинга: вместо привязывания представления к интерфейсу, мы привязываем элементы представления к параметрам view-модели.  


![](../.gitbook/assets/image%20%2834%29.png)

 Данный подход позволяет связывать элементы представления со свойствами и событиями View-модели. 

### **Общие правила выбора паттерна**

**MVVM**

* Используется в ситуации, когда возможно связывание данных без необходимости ввода специальных интерфейсов представления \(т.е. отсутствует необходимость реализовывать IView\);
* Частым примером является технология WPF.

**MVP**

* Используется в ситуации, когда невозможно связывание данных \(нельзя использовать Binding\);
* Частым примером может быть использование Windows Forms.

**MVC**

* Используется в ситуации, когда связь между представление и другими частями приложения невозможна \(и Вы не можете использовать MVVM или MVP\);
* Частым примером использования может служить ASP.NET MVC.

## Другие понятия

**Побочный эффект \(side effects\)** — любые действия работающей программы, изменяющие среду выполнения \(execution environment\). Например, к побочным эффектам относятся:

* доступ \(чтение или запись\) к объекту, определённому с модификатором [volatile](https://en.wikipedia.org/wiki/volatile_%28computer_programming%29) \(англ.\);
* изменение \(запись\) объекта;
* изменение файла;
* изменение поведения инструкций процессора, обрабатывающих числа с плавающей точкой;
* вызов функции, выполняющей любое из перечисленных выше действий.

**Побочный эффект функции** — возможность в процессе выполнения своих вычислений: читать и модифицировать значения глобальных переменных, осуществлять операции ввода-вывода, реагировать на исключительные ситуации, вызывать их обработчики. Если вызвать функцию с побочным эффектом дважды с одним и тем же набором значений входных аргументов, может случиться так, что в качестве результата будут возвращены разные значения. Такие функции называются недетерминированными функциями с побочными эффектами.

**Чистая функция** — функция, которая:

1. является детерминированной, для одного и того же набора входных значений она возвращает одинаковый результат.
2. не обладает побочными эффектами.

## File transfer protocols

**FTP**  – это протокол прикладного уровня, который, как правило, использует в качестве  транспортного  протокола  TCP. Предназначен:

* для  решения  задач  разделения  доступа  к  файлам  на   удаленных  хостах.
* прямого  или  косвенного  использования  ресурсов  удаленных   компьютеров.
* обеспечения независимости клиента от файловых систем удаленных   хостов.
*  эффективной и надежной передачи данных

FTP  не  может  использоваться  для передачи  конфиденциальных  данных,  поскольку  не  обеспечивает  защиты передаваемой информации и передает между сервером и клиентом открытый текст. 

 **Сетевой протокол сеансового уровня SSH** \(от английского Secure SHell\) дает возможность проводить удаленное управления ОС и туннелирование TCP-соединений.  SSH шифрует трафик и пароли, которые передаются. Для того, чтобы использовать shell доступ необходимо установить SSH-клиент, к примеру, Putty для ОС Windows.

 **Протокол прикладного уровня sftp** был разработан как расширение к  SSH-2. Используется для копирования и выполнения операций с файлами поверх безопасного соединения. В большинстве случаев использует порт 22. sftp предполагает, что он работает поверх установленного безопасного канала, что сервер уже аутентифицировал клиента и что идентификатор клиента доступен протоколу.

 **SSL** \([англ.](https://ru.wikipedia.org/wiki/%D0%90%D0%BD%D0%B3%D0%BB%D0%B8%D0%B9%D1%81%D0%BA%D0%B8%D0%B9_%D1%8F%D0%B7%D1%8B%D0%BA) Secure Sockets Layer — уровень защищённых [cокетов](https://ru.wikipedia.org/wiki/%D0%A1%D0%BE%D0%BA%D0%B5%D1%82_%28%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%BD%D1%8B%D0%B9_%D0%B8%D0%BD%D1%82%D0%B5%D1%80%D1%84%D0%B5%D0%B9%D1%81%29)\) — [криптографический протокол](https://ru.wikipedia.org/wiki/%D0%9A%D1%80%D0%B8%D0%BF%D1%82%D0%BE%D0%B3%D1%80%D0%B0%D1%84%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%B8%D0%B9_%D0%BF%D1%80%D0%BE%D1%82%D0%BE%D0%BA%D0%BE%D0%BB), который подразумевает более безопасную связь. Он использует асимметричную криптографию для аутентификации ключей обмена, симметричное шифрование для сохранения конфиденциальности, коды аутентификации сообщений для целостности сообщений.

 **FTPS \(File Transfer Protocol + SSL, или FTP/SSL\)** — это расширение широко используемого протокола передачи данных [FTP](https://ru.wikipedia.org/wiki/FTP), которое добавляет поддержку для криптографических протоколов уровней [транспортной безопасности](https://ru.wikipedia.org/wiki/TLS) и [защищенных сокетов](https://ru.wikipedia.org/wiki/SSL).

## RESTful API

REST \(representational state transfer — «передача состояния представления»\) или, лучше сказать, представление данных в удобном для клиента формате.  Основная идея REST в том, что каждое обращение к сервису переводит клиентское приложение в новое состояние. По сути, REST — не протокол и не стандарт, а подход, архитектурный стиль проектирования API.

**Каковы принципы REST?**

* **Клиент-серверная архитектура** — без этого REST немыслим.
* **Любые данные — ресурс**.
* **Любой ресурс имеет ID**, по которому можно получить данные.
* **Ресурсы могут быть связаны между собой** — для этого в составе ответа передается либо ID, либо, как чаще рекомендуется, ссылка. 
* **Используются стандартные методы HTTP** \(GET, POST, PUT, DELETE\) — т.к. они уже заложены в составе протокола, мы их можем использовать для того, чтобы построить каркас взаимодействия с нашим сервером.
* **Сервер не хранит состояние** — это значит, сервер не отделяет один вызов от другого, не сохраняет все сессии в памяти. Если у вас есть какое-либо масштабируемое облако, какая-то ферма из серверов, которая реализует ваш сервис, нет необходимости обеспечивать согласованность состояния этих сервисов между всеми узлами, которые у вас есть. Это сильно упрощает масштабирование — при добавлении еще одного узла все прекрасно работает.

### REST API Best Practices

####  **1. Конечные точки в URL – имя существительное, не глагол**

 Вы должны всегда использовать существительные вместо глаголов.

 _**Best Practice:**_  
  
Имеем единственную конечную точку, которая отвечает за все действия. В примере ниже представлена только одна конечная точка /farmers для всех операций таких как добавление, обновление, удаление. Базовые реализации имеют различные HTTP методы, которые правильно маршрутизируются для разных операций.  
  
• /farmers  
• /crops  
  
_**Не рекомендуется:**_  
  
Постарайтесь избегать использования глаголов. Рекомендуется представлять операции внутри таких форматах как JSON, XML, RAML или использовать HTTP методы. Не используйте представленные ниже обозначения:  
  
• /getFarmers  
• /updateFarmers  
• /deleteFarmers  
• /getCrops  
• /updateCrops  
• /deleteCrops

####  **2. Множественное число**

 Используйте множественное число для названия своих REST сервисов.

 _**Best Practice:**_  
  
• /farmers  
• /farmers/{farmer\_id}  
• /crops  
• /crops/{crop\_id}  
  
_**Не рекомендуется:**_  
  
• /farmer  
• /farmer/{farmer\_id}

####  3. Документация

 Документирование программного обеспечения является общей практикой для всех разработчиков. Этой практики стоит придерживаться и при реализации REST приложений. Если писать полезную документацию, то она поможет другим разработчикам понять ваш код.  
Наиболее распространенным способом документирования REST приложений – это документация с перечисленными в ней конечными точками, и описывающая список операций для каждой из них. Есть множество инструментов, которые позволяют сделать это автоматически.  
  
Ниже представлены приложения, которые помогают документировать REST сервисы:  
  
• [DRF Docs](https://www.drfdocs.com/)  
• [Swagger](https://swagger.io/)  
• [Apiary](https://apiary.io/)

####  4. Версия вашего приложения

 _**Мультимедийный способ управления версиями:**_  
Этот подход отправляет информацию о версии в заголовке каждого запроса. Когда мы изменим тип и язык мультимедиа URI, мы перейдем к рассмотрению контента на основе заголовка. Этот способ является наиболее предпочтительным вариантом для управления версиями REST приложений.  
  
Пример информации в заголовке:  
  
GET /account/5555 HTTP/1.1  
Accept: application/vnd.farmers.v1+json  
  
HTTP/1.1 200 OK  
Content-Type: application/vnd.farmers.v1+json  
  
В мультимедийном подходе управления версиями клиент имеет возможность выбрать, какую версию запрашивать с сервера. Этот способ выглядит предпочтительней, чем подход с URI\(host/v2/farmers, host/v1/farmers\), но сложность возникает при кэшировании запросов с различными версиями, которые передаются через заголовок. Говоря простыми словами, когда клиент кэширует на основе URI, это просто, но, кэширование с ключом в качестве мультимедийного типа добавляет сложности.

####  5. Пагинация

 Отправка большого объема данных через HTTP не очень хорошая идея. Безусловно, возникнут проблемы с производительностью, поскольку сериализация больших объектов JSON станет дорогостоящей. Best practice является разбиение результатов на части, а не отправка всех записей сразу. Предоставьте возможность разбивать результаты на странице с помощью предыдущих или следующих ссылок.  


####  6. Использование SSL

 SSL должен быть! Вы всегда должны применять SSL для своего REST приложения. Доступ к вашему приложения будет осуществляется из любой точки мира, и нет никакой гарантии, что к нему будет обеспечен безопасный доступ. С ростом числа инцидентов с киберпреступностью мы обязательно должны обеспечить безопасность своему приложению. 

####  7. HTTP методы

 Ниже представлены две характеристики, которые должны быть определены перед использованием HTTP метода:

* Безопасность: HTTP метод считается безопасным, когда вызов этого метода не изменяет состояние данных. Например, когда вы извлекаете данные с помощью метода GET, это безопасно, потому что этот метод не обновляет данные на стороне сервера.
* Идемпотентность: когда вы получаете один и тот же ответ, сколько раз вы вызываете один и тот же ресурс, он известен как идемпотентный. Например, когда вы пытаетесь обновить одни и те же данные на сервере, ответ будет таким же для каждого запроса, сделанного с одинаковыми данными.

![](../.gitbook/assets/image%20%2823%29.png)

 Краткий обзор каждого метода и рекомендации по их использованию:

* `GET` - обычно используется для извлечения информации и не имеет побочных эффектов.
* `POST` - этот метод наиболее широко используется для создания ресурсов.
* `PUT` - используется для обновления ресурсов. 
*  `PATCH`  - предоставляет частичную модификацию ресурса. Например, если нужно обновить только одно поле для ресурса
* `DELETE`- этот метод используется для удаления ресурсов.
* `OPTIONS` этот метод не используется для каких-либо манипуляций с ресурсами. Но он полезен, когда клиент не знает других методов, поддерживаемых для ресурса, и используя этот метод, клиент может получить различное представление ресурса.
* `HEAD` этот метод используется для запроса ресурса c сервера. Он очень похож на метод GET, но HEAD должен отправлять запрос и получать ответ только в заголовке. Согласно спецификации HTTP, этот метод не должен использовать тело для запроса и ответа.

####  8. Эффективное использование кодов ответов HTTP

* **200 OK** — это ответ на успешные GET, PUT, PATCH или DELETE. Этот код также используется для POST, который не приводит к созданию.
* **201 Created** — этот код состояния является ответом на POST, который приводит к созданию.
* **204 Нет содержимого.** Это ответ на успешный запрос, который не будет возвращать тело \(например, запрос DELETE\).
* **300 Multiple Choices** — по указанному URI существует несколько вариантов предоставления ресурса по типу [MIME](https://ru.wikipedia.org/wiki/MIME), по языку или по другим характеристикам. Сервер передаёт с сообщением список альтернатив, давая возможность сделать выбор клиенту автоматически или пользователю. 
* **301 Moved Permanently** — запрошенный документ был окончательно перенесен на новый URI, указанный в поле `Location`заголовка. 
* **302 Found, 302 Moved Temporarily** — запрошенный документ временно доступен по другому URI, указанному в заголовке в поле `Location`. 
* **304 Not Modified** — используйте этот код состояния, когда заголовки HTTP-кеширования находятся в работе
* **400 Bad Request** — этот код состояния указывает, что запрос искажен, например, если тело не может быть проанализировано
* **401 Unauthorized** — Если не указаны или недействительны данные аутентификации. Также полезно активировать всплывающее окно auth, если приложение используется из браузера
* **403 Forbidden** — когда аутентификация прошла успешно, но аутентифицированный пользователь не имеет доступа к ресурсу
* **404 Not found** — если запрашивается несуществующий ресурс
* **405 Method Not Allowed** — когда запрашивается HTTP-метод, который не разрешен для аутентифицированного пользователя
* **410 Gone** — этот код состояния указывает, что ресурс в этой конечной точке больше не доступен. Полезно в качестве защитного ответа для старых версий API
* **415 Unsupported Media Type.** Если в качестве части запроса был указан неправильный тип содержимого
* **422 Unprocessable Entity** — используется для проверки ошибок
* **429 Too Many Requests** — когда запрос отклоняется из-за ограничения скорости.

[Полный список кодов состояния HTTP](https://ru.wikipedia.org/wiki/%D0%A1%D0%BF%D0%B8%D1%81%D0%BE%D0%BA_%D0%BA%D0%BE%D0%B4%D0%BE%D0%B2_%D1%81%D0%BE%D1%81%D1%82%D0%BE%D1%8F%D0%BD%D0%B8%D1%8F_HTTP)



