# Version Control System

**Система контроля версий** \(Version Control System, VCS или Revision Control System\) — программное обеспечение для облегчения работы с изменяющейся информацией. Система контроля версиями позволяет хранить несколько версий одного и того же документа, при необходимости возвращаться к более ранним версиям, определять, кто и когда сделал то или иное изменение, и многое другое.

## GIT

**Git** — распределённая система управления версиями. Проект был создан Линусом Торвальдсом для управления разработкой ядра Linux, первая версия выпущена 7 апреля 2005 года. На сегодняшний день его поддерживает Джунио Хамано.

[Как работает Git](https://habr.com/post/313890/)

[https://education.github.com/git-cheat-sheet-education.pdf](https://education.github.com/git-cheat-sheet-education.pdf)

[https://services.github.com/on-demand/downloads/github-git-cheat-sheet.pdf](https://services.github.com/on-demand/downloads/github-git-cheat-sheet.pdf)

### **Git issues**

Краткий обзор: [https://www.youtube.com/watch?v=YshvUGgF\_3o](https://www.youtube.com/watch?v=YshvUGgF_3o)

Git issues – это система контроля ошибок, более упрощенная и визуально простая по сравнению с Jira. Особенностью является интегрирование с Pull Request и другими функциями GitHub. что дает возможность online просмотреть внесенные изменения и прокомментировать их.

Эта система позволяет владельцу репозитория создавать задачу, кратко ее описывать и назначать ответственного за решение этой задачи среди людей, которые включены в данный репозиторий \(своеобразный аналог ToDo List\). Гибкость системе контроля ошибок придает возможность проставления различных меток, которые обозначают проблему \(баг, вопрос, расширение функционала и т.д.\). GitHub не только предоставляет стандартный набор меток, но и позволяет создавать свои собственные. Основная система контроля выполнения заданий – это **Open** \(задание в работе\) и **Closed** \(задание завершено\). Даже завершенные задания сохраняются, что дает возможность всегда их просмотреть. При создании задачи ей присваивается уникальный ID, ссылаясь на который всегда можно обратиться к этой задаче. Также под задачей отображается список изменений и дискуссия по поводу этой задачи.

### **Операции отмены при коммитах:**

1\) **Сделали коммит слишком рано**, например, забыв добавить какие-то файлы или комментарий к коммиту. Если вы хотите переделать коммит, можно запустить commit с параметром **--amend** \(дополнить\):

$ git commit --amend

Эта команда использует для дополнения коммита вашу область подготовки \(индекс\). Если вы ничего не меняли с момента последнего коммита \(например, команда запущена сразу после предыдущего коммита\), то снимок состояния останется в точности таким же, а изменится лишь комментарий к коммиту. Запустится тот же редактор комментария к коммиту, но уже с комментарием к предыдущему коммиту. Комментарий можно отредактировать точно так же, как обычно, просто он заменит собой предыдущий.

2\) **Отмена подготовки файла**. Например, набрали комманду git add, но затем хотите убрать файл:

$ git reset HEAD \(имя файла\)

3\) **Отмена изменения измененного файла** с помощью “**--**”\(**двойной дефис**\). Чтобы вернуть к тому виду, который был в последнем коммите, т.е. Вы не хотите сохранять свои изменения файла \(«разызменить» его\):

$ git checkout – \(имя файла\)

### reset

 Команда `reset` в заранее определенном порядке перезаписывает три дерева Git, останавливаясь тогда, когда вы ей скажете

![](../.gitbook/assets/image%20%2826%29.png)

![](../.gitbook/assets/image%20%2828%29.png)

### Branching

**GitFlow** is a branching model for Git, created by Vincent Driessen. It has attracted a lot of attention because it is very well suited to collaboration and scaling the development team [https://datasift.github.io/gitflow/IntroducingGitFlow.html](https://datasift.github.io/gitflow/IntroducingGitFlow.html)

![](../.gitbook/assets/git-flow.png)

 Слияние \(merge\) с основной веткой для включения в продукт. Это делается командой `git merge master`:

![](../.gitbook/assets/image%20%2836%29.png)

 После внедрения вашего архиважного исправления вы готовы вернуться к работе над тем, что были вынуждены отложить. Но сначала нужно удалить ветку `hotfix`, потому что она больше не нужна — ветка `master` указывает на то же самое место. Для удаления ветки выполните команду `git branch` с параметром `-d`

 Стоит обратить внимание на то, что все изменения из ветки `hotfix` не включены в вашу ветку `iss53`. Если их нужно включить, вы можете влить ветку `master` в вашу ветку `iss53` командой `git merge master`, или же вы можете отложить слияние этих изменений до завершения работы, и затем влить ветку `iss53` в `master`.

При слиянии iss53 с веткой мастер,  вместо того, чтобы просто передвинуть указатель ветки вперед, Git создает новый снимок-результат трехстороннего слияния, а затем автоматически делает коммит. Этот особый коммит называют коммитом слияния, так как у него более одного предка.

![](../.gitbook/assets/image%20%2813%29.png)

 Иногда процесс не проходит гладко. Если вы изменили одну и ту же часть одного и того же файла по-разному в двух объединяемых ветках, Git не сможет их чисто объединить.

### **“Git merge” vs “git rebase”**.

В Git'е есть два способа включить изменения из одной ветки в другую: merge \(слияние\) и rebase \(перемещение\). Наиболее простое решение для объединения веток – это команда **merge**:

$ git merge С3

Эта команда выполняет трёхходовое слияние между двумя последними снимками состояний из веток \(C3 и C4\) и последним общим предком этих двух веток \(C2\), создавая новый снимок состояния \(и коммит\). Таким образом сохраняются две независимые ветки изменений. Финальное состояние С5 будет иметь двух предков – С3 и С4.

![&#x421;&#x43B;&#x438;&#x44F;&#x43D;&#x438;&#x435; &#x434;&#x432;&#x443;&#x445; &#x432;&#x435;&#x442;&#x43E;&#x43A; &#x441; &#x43F;&#x43E;&#x43C;&#x43E;&#x449;&#x44C;&#x44E; &quot;git merge&quot;](../.gitbook/assets/git-merge.png)

Однако, есть и другой путь: Вы можете взять изменения, представленные в C3, и применить их после C4. В Git'е это называется перемещение \(rebasing\). При помощи команды **rebase** вы можете взять все изменения, которые попали в коммиты на одной из веток, и повторить их на другой.

$ git checkout experiment

$ git rebase master

Перемещение работает следующим образом: находится общий предок для двух веток \(на которой вы находитесь сейчас и на которую вы выполняете перемещение\); для каждого из коммитов в текущей ветке берётся его дельта и сохраняется во временный файл; текущая ветка устанавливается на тот же коммит, что и ветка, на которую выполняется перемещение; и, наконец, одно за другим применяются все изменения. Таким образом изменения вносятся не на этапе предка С2, а цепочка идет по пути: С2 – С4 – С3’.

![&#x421;&#x43B;&#x438;&#x44F;&#x43D;&#x438;&#x435; &#x434;&#x432;&#x443;&#x445; &#x432;&#x435;&#x442;&#x43E;&#x43A; &#x441; &#x43F;&#x43E;&#x43C;&#x43E;&#x449;&#x44C;&#x44E; &quot;git rebase&quot;.](../.gitbook/assets/git-rebase.png)

Команду **rebase** рекомендуется применять в частных репозиториях для предотвращения безграничного ветвления и упорядочивания порядка коммитов. Команду **merge** лучше применять для внесения изменений в публичные репозитории, когда коммиты от разных авторов имеют разных предков, сохраняют свою история изменений с самого общего начала и паралельно вливаются друг в друга.

## CVS \(с**истема одновременных версий\)**

**Преимущества:**

* Испытанная временем технология, которая удерживается на рынке десятки лет.

**Недостатки:**

* Переименование или перемещение файлов не отражается в истории
* Риски безопасности, связанные с символическими ссылками на файлы
* Нет поддержки атомарных операций, что может привести к повреждению кода
* Операции с ветками программного кода дорогостоящие, так как эта система контроля не предназначена для долгосрочных проектов с ветками кода

## SVN 

Subversion \(также известная как «SVN»\) — свободная централизованная система управления версиями, официально выпущенная в 2004 году компанией CollabNet. С 2010 года Subversion является одним из проектов Apache Software Foundation и официально называется Apache Subversion \(зарегистрированный товарный знак​\).

[**SVN**](http://subversion.apache.org/) создавалась как альтернатива CVS с целью исправить недостатки CVS и в то же время обеспечить высокую совместимость с ней.

**Преимущества:** 

* Система на основе CVS
* Допускает атомарные операции
* Операции с ветвлением кода менее затратны
* Широкий выбор плагинов IDE
* Не использует пиринговую модель

**Недостатки:**

* Сохраняются ошибки, связанные с переименованием файлов/директорий
* Неудовлетворительный набор команд для работы с репозиторием
* Сравнительно небольшая скорость

  
В SVN мы, как правило, работали с одной веткой trunk \(в git ветка, с которой мы работаем по умолчанию, называется master\). Эта же ветка заливалась на продакшн. Главное неудобство здесь — то, что если мы производим какие-то изменения, или разрабатываем новый функционал, мы вынуждены либо сидеть и не коммитить до тех пор, пока задача не будет доделана до конца, либо \(если нам нужна помощь коллеги\), закоммитить недоделанный функционал, как есть, сделав таким образом trunk непригодным к заливке на продакшн.

![](../.gitbook/assets/650px-subversion_project_visualization.svg.png)

